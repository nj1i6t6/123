<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 圖像辨識翻譯</title>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --danger-color: #dc3545;
            --background-color: #f8f9fa;
            --text-color: #212529;
            --card-bg: #ffffff;
            --border-radius: 8px;
            --box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 500px;
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
        }
        h1 {
            color: var(--primary-color);
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        input[type="text"],
        input[type="password"],
        select,
        input[type="range"] {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: var(--border-radius);
            font-size: 1em;
        }
        input[type="range"] {
             padding: 0;
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 1em;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.3s ease, opacity 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
        button.secondary {
            background-color: var(--secondary-color);
        }
        button.secondary:hover:not(:disabled) {
            background-color: #545b62;
        }
        button.danger {
            background-color: var(--danger-color);
        }
        button.danger:hover:not(:disabled) {
            background-color: #c82333;
        }

        #cameraView, #appView {
            width: 100%;
        }
        #videoPreview {
            width: 100%;
            max-width: 480px;
            height: auto;
            border: 1px solid #ccc;
            background-color: #000;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            cursor: pointer;
        }
        #capturedImage {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            display: none;
        }
        .info-display-area, .error-display-area {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: var(--border-radius);
            min-height: 50px;
            word-wrap: break-word;
            font-size: 0.95em;
            white-space: pre-wrap;
            position: relative;
        }
        .error-display-area {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info-display-area h1, 
        .info-display-area h2, 
        .info-display-area h3, 
        .info-display-area h4, 
        .info-display-area h5, 
        .info-display-area h6 {
            margin-top: 1em; margin-bottom: 0.5em; color: var(--primary-color); font-weight: bold;
        }
        .info-display-area h1 { font-size: 1.5em; }
        .info-display-area h2 { font-size: 1.3em; }
        .info-display-area h3 { font-size: 1.2em; }
        .info-display-area p { margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.6; }
        .info-display-area ul, .info-display-area ol { margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 20px; }
        .info-display-area li { margin-bottom: 0.3em; }
        .info-display-area hr { border: 0; height: 1px; background-color: #ccc; margin: 1em 0; }
        .info-display-area strong { font-weight: bold; }
        .info-display-area table { width: 100%; border-collapse: collapse; margin-top: 1em; margin-bottom: 1em; }
        .info-display-area th, .info-display-area td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .info-display-area th { background-color: #f2f2f2; font-weight: bold; }
        .hidden {
            display: none !important;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .button-group button {
            flex: 1;
            margin-top: 0; 
            margin-bottom: 0;
        }
        #zoomControls {
            margin-top: 5px;
            margin-bottom: 10px;
        }
        #zoomControls label {
            font-size: 0.9em;
            margin-right: 5px;
        }
        #zoomSlider {
            width: calc(100% - 70px);
            vertical-align: middle;
        }
        .copy-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            padding: 5px 8px;
            font-size: 0.8em;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            z-index: 10;
            opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s;
            width: auto;
        }
        .copy-button:hover:not(:disabled) {
            opacity: 1;
            background-color: #545b62;
        }
        #cameraLoadingIndicator {
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="settingsView" class="container">
        <h1>設定</h1>
        <div>
            <label for="apiKey" data-i18n="apiKeyLabel">API 金鑰:</label>
            <input type="password" id="apiKey" placeholder="請輸入您的 Gemini API 金鑰" aria-required="true">
        </div>
        <div>
            <label for="targetLanguage" data-i18n="languageLabel">目標語言:</label>
            <select id="targetLanguage">
                <option value="zh-TW">繁體中文 (台灣)</option>
                <option value="en">English</option>
                <option value="ja">日本語</option>
                <option value="ko">한국어</option>
            </select>
        </div>
        <button id="saveSettings" data-i18n="saveSettingsButton">儲存設定並開始</button>
    </div>

    <div id="appView" class="container hidden">
        <h1 data-i18n="appTitle">圖像辨識</h1>
        
        <div id="cameraLoadingIndicator" class="loader hidden" aria-busy="true" aria-live="assertive" data-i18n="cameraLoadingText">相機啟動中...</div>
        
        <div id="cameraView">
            <video id="videoPreview" autoplay playsinline></video>
            <div id="zoomControls" class="hidden">
                <label for="zoomSlider" data-i18n="zoomLabel">縮放:</label>
                <input type="range" id="zoomSlider" min="1" max="1" step="0.1" value="1">
            </div>
            <div class="button-group" style="margin-bottom: 10px;">
                <button id="captureButton" data-i18n="captureButton" aria-label="拍攝照片">拍攝</button>
                <button id="uploadButton" data-i18n="uploadButtonLabel" aria-label="從檔案選擇圖片">從檔案選擇</button>
            </div>
            <input type="file" id="imageUploadInput" class="hidden" accept="image/*">
            <canvas id="canvas" class="hidden"></canvas>
        </div>
        
        <div id="controlsAfterCapture" class="hidden">
            <img id="capturedImage" alt="Captured Image">
            <p id="promptHelper" data-i18n="promptHelperText">已拍攝照片。點擊下方按鈕進行描述。</p>
            <div class="button-group">
                <button id="describeButton" data-i18n="describeButton">這是什麼？</button>
                <button id="menuModeButton" data-i18n="menuModeButton">翻譯菜單</button>
            </div>
            <div class="button-group">
                <button id="recaptureButton" class="secondary" data-i18n="recaptureButton">重新拍攝</button>
                <button id="downloadImageButton" class="secondary" data-i18n="downloadImageButtonLabel">下載圖片</button>
            </div>
        </div>

        <div id="apiInteractionControls" class="hidden" style="margin-top: 15px;">
             <button id="cancelApiRequestButton" class="danger" data-i18n="cancelRequestButton">取消請求</button>
        </div>

        <div id="loadingIndicator" class="loader hidden" aria-busy="true" aria-live="polite"></div>
        <div id="errorDisplay" class="error-display-area hidden" role="alert" aria-live="assertive"></div>
        <div id="resultArea" class="info-display-area" data-i18n-placeholder="resultPlaceholder" aria-live="polite">辨識結果將顯示於此
            <button class="copy-button" data-clipboard-target-id="resultArea" title="複製內容" style="display:none;">複製</button>
        </div>
        
        <button id="tellMeMoreButton" class="secondary hidden" data-i18n="tellMeMoreButtonLabel" style="margin-top: 15px;">告訴我更多</button>
        <div id="moreInfoLoadingIndicator" class="loader hidden" aria-busy="true" aria-live="polite"></div>
        <div id="moreInfoArea" class="info-display-area hidden" data-i18n-placeholder="moreInfoPlaceholder" style="margin-top:10px;" aria-live="polite">更多資訊將顯示於此
            <button class="copy-button" data-clipboard-target-id="moreInfoArea" title="複製內容" style="display:none;">複製</button>
        </div>

        <button id="backToSettings" class="secondary" data-i18n="backToSettingsButton" style="margin-top: 20px;">返回設定</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
        const DEBUG_MODE = localStorage.getItem('debugApp') === 'true';

        const GlobalConstants = {
            GEMINI_API_BASE_URL: 'https://generativelanguage.googleapis.com/v1beta/models/',
            GEMINI_MODEL_STREAM: 'gemini-2.5-flash-preview-05-20:streamGenerateContent',
            DEFAULT_BLANK_IMAGE: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="
        };
        
        const DOM = {
            settingsView: document.getElementById('settingsView'),
            appView: document.getElementById('appView'),
            apiKeyInput: document.getElementById('apiKey'),
            targetLanguageSelect: document.getElementById('targetLanguage'),
            saveSettingsButton: document.getElementById('saveSettings'),
            
            cameraLoadingIndicator: document.getElementById('cameraLoadingIndicator'),
            cameraViewDiv: document.getElementById('cameraView'),
            videoPreview: document.getElementById('videoPreview'),
            canvas: document.getElementById('canvas'),
            captureButton: document.getElementById('captureButton'),
            uploadButton: document.getElementById('uploadButton'),
            imageUploadInput: document.getElementById('imageUploadInput'),
            zoomControls: document.getElementById('zoomControls'),
            zoomSlider: document.getElementById('zoomSlider'),

            capturedImage: document.getElementById('capturedImage'),
            controlsAfterCapture: document.getElementById('controlsAfterCapture'),
            describeButton: document.getElementById('describeButton'),
            menuModeButton: document.getElementById('menuModeButton'),
            recaptureButton: document.getElementById('recaptureButton'),
            downloadImageButton: document.getElementById('downloadImageButton'),
            
            apiInteractionControls: document.getElementById('apiInteractionControls'),
            cancelApiRequestButton: document.getElementById('cancelApiRequestButton'),

            loadingIndicator: document.getElementById('loadingIndicator'),
            errorDisplay: document.getElementById('errorDisplay'),
            resultArea: document.getElementById('resultArea'),
            backToSettingsButton: document.getElementById('backToSettings'),
            promptHelper: document.getElementById('promptHelper'),

            tellMeMoreButton: document.getElementById('tellMeMoreButton'),
            moreInfoLoadingIndicator: document.getElementById('moreInfoLoadingIndicator'),
            moreInfoArea: document.getElementById('moreInfoArea'),
        };

        const AppState = {
            stream: null,
            videoTrack: null,
            currentApiKey: '',
            currentTargetLanguage: 'zh-TW',
            currentRequestMode: 'describe', // 'describe' or 'menu'
            isApiRequestInProgress: false,
            currentAbortController: null,
        };
        
        const i18nData = {
            'zh-TW': {
                apiKeyLabel: 'API 金鑰:', languageLabel: '目標語言:', saveSettingsButton: '儲存設定並開始',
                appTitle: '這是啥？AI幫你看', cameraLoadingText: '相機啟動中...', captureButton: '拍攝', uploadButtonLabel: '從檔案選擇', zoomLabel: '縮放:',
                describeButton: '這是什麼？', menuModeButton: '翻譯菜單', recaptureButton: '重新拍攝', downloadImageButtonLabel: '下載圖片',
                resultPlaceholder: 'AI 的分析結果會顯示在這裡喔！', backToSettingsButton: '返回設定',
                alert_apiKeyRequired: '請先輸入你的 API 金鑰啦！', alert_cameraError: '哎呀，相機打不開捏: ', alert_apiError: 'API 請求失敗，再試一次看看？ ',
                alert_noImage: '要先拍張照片或上傳圖片才能分析啦！', promptHelperText: '照片已準備好！點擊下方按鈕讓 AI 幫你看。',
                apiPrompt: `這張照片裡是什麼東西？請你嚴格依照以下「回覆樣板」的格式，並使用輕鬆、口語化的台灣用語（繁體中文，即 ${() => AppState.currentTargetLanguage}）來回答。請根據圖片內容填寫 [方括號] 中的資訊。如果某項資訊在圖片中無法辨識，請在對應的 [方括號] 中填寫「看不太清楚耶」或「圖片裡沒有顯示喔」。如果沒有特別的品牌或型號資訊，該部分也填寫「看不太清楚耶」。\n\n**如果圖片主要內容是菜單或價目表：**\n請讓「品名」為「菜單」或「價目表」，「用途」為「提供餐點資訊與價格」，「價格」為「包含多項品項價格」。並且在「其他觀察到的資訊」中特別提醒：「這似乎是一份菜單喔！點擊『翻譯菜單』按鈕可以查看詳細翻譯與價格，或點『告訴我更多』以獲取菜單項目解說。」\n\n回覆樣板：\n這叫做「[物品的台灣口語化通稱或品名]」。\n用途（或主要成分，依圖片判斷）是「[描述用途/主要成分/特色]」。\n價格「[如果圖片中有價格請提供，若無則填寫上述提示，例如：約 NT$XXX元 或 價格未顯示喔]」。\n\n如果圖片中有清晰的品牌名稱、型號或其他重要文字，請在最後補充一行：「其他觀察到的資訊有：[品牌、型號等文字，若無則填寫 看不太清楚耶]」。\n請確保回答自然流暢，謝謝！`,
                apiResponsePrefix: 'AI 說：\n', tellMeMoreButtonLabel: '告訴我更多關於它',
                apiPromptMoreInfo: `請針對這張圖片中的主要物品，提供比之前初步描述更詳細的補充資訊。內容可以包含（但不限於）：使用教學、料理建議（如果適用）、保養存放（如果適用）、哪裡買/取得、相關提醒。請用輕鬆口語、條理分明的台灣用語（繁體中文，即 ${() => AppState.currentTargetLanguage}）來介紹，讓內容更豐富實用。請使用 Markdown 格式（例如標題、列表、粗體）來讓內容更易讀，但不要使用太複雜的 Markdown 符號。`,
                apiPromptMenuInitial: `這是一張菜單或價目表的圖片。請你擔任專業的菜單翻譯員。嚴格依照以下「回覆樣板」的格式，將圖片中所有清晰可見的品項，逐一列出其「原文」、對應到「目標語言（${() => AppState.currentTargetLanguage}）的道地口語化翻譯」、以及圖片中顯示的「價格」。\n- 如果某品項的原文、翻譯或價格在圖片中不清晰，請在對應欄位註明「原文不清」、「翻譯困難」或「價格未顯示」。\n- 請確保翻譯符合目標語言的餐飲習慣用語。\n- 僅列出品項、翻譯和價格，不要有其他額外描述。\n- 如果圖片內容看起來並非菜單，請直接回覆「這似乎不是一份菜單，無法進行菜單翻譯。」\n\n回覆樣板 (使用 Markdown 列表)：\n- 原文: [品項原文1], 翻譯: [品項翻譯1], 價格: [價格1]\n- 原文: [品項原文2], 翻譯: [品項翻譯2], 價格: [價格2]\n...`,
                apiPromptMenuMoreInfo: `接續先前的菜單翻譯結果，現在請你針對這張菜單圖片中的每一個品項，如果可能的話，提供簡短的「品項解說」。\n- 解說內容可以包含：主要食材、風味特色、份量大小的猜測、或是任何你認為對點餐有幫助的補充資訊。\n- 語言請使用目標語言（${() => AppState.currentTargetLanguage}）的道地口語。\n- 格式請依然先列出「原文」、「翻譯」、「價格」，然後在其下方加上「解說」。\n\n回覆樣板 (使用 Markdown)：\n- 原文: [品項原文1], 翻譯: [品項翻譯1], 價格: [價格1]\n  解說: [對品項1的解說...]\n- 原文: [品項原文2], 翻譯: [品項翻譯2], 價格: [價格2]\n  解說: [對品項2的解說...]\n...\n\n如果圖片內容看起來並非菜單，或先前的翻譯結果顯示非菜單，請直接回覆「無法提供更多關於非菜單內容的解說。」`,
                moreInfoPlaceholder: '更多詳細資訊會顯示在這裡～', moreInfoPrefix: 'AI 補充說明：\n',
                copyButtonText: '複製', copiedButtonText: '已複製!', copyFailedAlert: '複製失敗!', noContentCopyAlert: '沒有內容可以複製。',
                cancelRequestButton: '取消請求', requestCancelledMessage: '請求已取消。', genericError: '發生未知錯誤，請稍後再試。'
            },
            'en': {
                apiKeyLabel: 'API Key:', languageLabel: 'Target Language:', saveSettingsButton: 'Save Settings & Start',
                appTitle: "What's This? AI Vision", cameraLoadingText: 'Starting camera...', captureButton: 'Capture', uploadButtonLabel: 'Upload Image', zoomLabel: 'Zoom:',
                describeButton: "What's this?", menuModeButton: 'Translate Menu', recaptureButton: 'Recapture', downloadImageButtonLabel: 'Download Image',
                resultPlaceholder: 'AI analysis will appear here!', backToSettingsButton: 'Back to Settings',
                alert_apiKeyRequired: 'Please enter your API Key.', alert_cameraError: 'Could not start camera: ', alert_apiError: 'API request failed. Try again? ',
                alert_noImage: 'Please capture or upload an image first!', promptHelperText: 'Image ready! Click a button below for AI to analyze.',
                apiPrompt: `What is in this picture? Please strictly follow the "Response Template" format below and use simple, clear English (i.e., ${() => AppState.currentTargetLanguage}). Fill in the information in [square brackets] based on the image content. If some information cannot be identified from the image, please write "Not clear" or "Not shown in image" in the corresponding [bracket]. If no specific brand or model information is available, also write "Not clear".\n\n**If the main content of the image is a menu or price list:**\nPlease set the "Name" to "Menu" or "Price List", "Purpose" to "Provides meal information and prices", and "Price" to "Contains prices for multiple items". Also, in "Other observed information", specifically prompt the user: "This seems to be a menu! Click 'Translate Menu' for detailed translation and prices, or 'Tell me more' for item explanations."\n\nResponse Template:\nThis is called "[common name or product name]".\nIts purpose (or main ingredients, judge by image) is "[describe purpose/main ingredients/features]".\nThe price is "[provide if price is visible in image, otherwise use above hints, e.g., approx. $XX or Price not shown]".\n\nIf there are clear brand names, model numbers, or other important text in the image, add a line at the end: "Other observed information: [brand, model, etc., if none then write Not clear]".\nPlease ensure the answer is natural and fluent. Thanks!`,
                apiResponsePrefix: 'AI says:\n', tellMeMoreButtonLabel: 'Tell me more about it',
                apiPromptMoreInfo: `Please provide more detailed supplementary information about the main item in this picture than the initial description. Content can include (but is not limited to): usage instructions, cooking suggestions (if applicable), maintenance/storage (if applicable), where to buy/get it, relevant reminders. Please use clear, well-organized English (i.e., ${() => AppState.currentTargetLanguage}) to introduce, making the content richer and more practical. Use Markdown format (e.g., headings, lists, bold) for readability, but avoid overly complex Markdown.`,
                apiPromptMenuInitial: `This is an image of a menu or price list. Act as a professional menu translator. Strictly follow the "Response Template" format below. For each clearly visible item in the image, list its "Original Text", its idiomatic translation into the "Target Language (${() => AppState.currentTargetLanguage})", and the "Price" shown in the image.\n- If the original text, translation, or price of an item is unclear in the image, note "Original unclear", "Translation difficult", or "Price not shown" in the respective field.\n- Ensure translations align with the target language's culinary terminology.\n- Only list items, translations, and prices, with no additional descriptions.\n- If the image content does not appear to be a menu, please respond directly with "This does not seem to be a menu; menu translation cannot be performed."\n\nResponse Template (using Markdown list):\n- Original: [Original Item 1], Translation: [Translated Item 1], Price: [Price 1]\n- Original: [Original Item 2], Translation: [Translated Item 2], Price: [Price 2]\n...`,
                apiPromptMenuMoreInfo: `Following up on the previous menu translation, now for each item in this menu image, please provide a brief "Item Explanation" if possible.\n- The explanation can include: main ingredients, flavor profile, portion size guess, or any supplementary information you deem helpful for ordering.\n- Please use idiomatic language of the target language (${() => AppState.currentTargetLanguage}).\n- For the format, still list "Original", "Translation", "Price", and then add "Explanation" below it.\n\nResponse Template (using Markdown):\n- Original: [Original Item 1], Translation: [Translated Item 1], Price: [Price 1]\n  Explanation: [Explanation for Item 1...]\n- Original: [Original Item 2], Translation: [Translated Item 2], Price: [Price 2]\n  Explanation: [Explanation for Item 2...]\n...\n\nIf the image content does not appear to be a menu, or the previous translation indicated it's not a menu, please respond directly with "Cannot provide more details for non-menu content."`,
                moreInfoPlaceholder: 'More detailed information will appear here!', moreInfoPrefix: 'AI adds:\n',
                copyButtonText: 'Copy', copiedButtonText: 'Copied!', copyFailedAlert: 'Copy failed!', noContentCopyAlert: 'No content to copy.',
                cancelRequestButton: 'Cancel Request', requestCancelledMessage: 'Request cancelled.', genericError: 'An unknown error occurred. Please try again later.'
            },
            'ja': {
                apiKeyLabel: 'APIキー:', languageLabel: 'ターゲット言語:', saveSettingsButton: '設定を保存して開始',
                appTitle: 'これは何？AI画像認識', cameraLoadingText: 'カメラ起動中...', captureButton: '撮影', uploadButtonLabel: '画像をアップロード', zoomLabel: 'ズーム:',
                describeButton: 'これは何？', menuModeButton: 'メニュー翻訳', recaptureButton: '再撮影', downloadImageButtonLabel: '画像をダウンロード',
                resultPlaceholder: 'AIの解析結果はここに表示されます！', backToSettingsButton: '設定に戻る',
                alert_apiKeyRequired: 'APIキーを入力してください。', alert_cameraError: 'カメラを起動できませんでした: ', alert_apiError: 'APIリクエストに失敗しました。もう一度試しますか？',
                alert_noImage: 'まず画像を撮影またはアップ로드してください！', promptHelperText: '画像準備完了！下のボタンをクリックしてAIに解析させてください。',
                apiPrompt: `この写真には何が写っていますか？以下の「回答テンプレート」の形式に厳密に従い、わかりやすく口語的な日本語（${() => AppState.currentTargetLanguage}）で回答してください。画像の内容に基づいて[角括弧]内の情報を記入してください。画像から情報が特定できない場合は、対応する[角括弧]に「不明瞭です」または「画像に表示されていません」と記入してください。特定のブランドやモデル情報がない場合も「不明瞭です」と記入してください。\n\n**画像が主にメニューまたは価格表である場合：**\n「品名」を「メニュー」または「価格表」、「用途」を「食事情報と価格の提供」、「価格」を「複数の品目の価格を含む」としてください。さらに、「その他観察された情報」で「これはメニューのようです！「メニュー翻訳」ボタンで詳細な翻訳と価格を確認するか、「もっと詳しく教えて」で項目解説を確認できます。」とユーザーに明確に促してください。\n\n回答テンプレート：\nこれは「[物品の一般的な呼称または品名]」と呼ばれます。\n用途（または主な成分、画像から判断）は「[用途/主な成分/特徴を記述]」です。\n価格は「[画像に価格が表示されていれば記入、なければ上記のヒントを使用。例：約XXX円または価格未表示です]」です。\n\n画像に明確なブランド名、モデル番号、その他の重要なテキストがある場合は、最後に一行追加してください：「その他観察された情報：[ブランド、モデルなど、なければ不明瞭です]」。\n回答は自然で流暢になるようお願いします。ありがとうございます！`,
                apiResponsePrefix: 'AIの解析：\n', tellMeMoreButtonLabel: 'もっと詳しく教えて',
                apiPromptMoreInfo: `この画像の主要なアイテムについて、最初の説明よりも詳細な補足情報を提供してください。内容は以下を含むことができます（ただしこれらに限定されません）：使用方法、料理の提案（該当する場合）、メンテナンス/保管（該当する場合）、購入/入手場所、関連する注意点。わかりやすく整理された日本語（${() => AppState.currentTargetLanguage}）で紹介し、内容をより豊かで実用的なものにしてください。Markdown形式（例：見出し、リスト、太字）を使用して読みやすくしてください。ただし、複雑すぎるMarkdown記号は避けてください。`,
                apiPromptMenuInitial: `これはメニューまたは価格表の画像です。プロのメニュー翻訳者として行動してください。以下の「回答テンプレート」の形式に厳密に従ってください。画像内の明確に見える各項目について、「原文」、「ターゲット言語（${() => AppState.currentTargetLanguage}）への自然な翻訳」、および画像に表示されている「価格」をリストアップしてください。\n- 項目の原文、翻訳、または価格が画像で不明確な場合は、それぞれのフィールドに「原文不明瞭」、「翻訳困難」、または「価格未表示」と記載してください。\n- 翻訳がターゲット言語の料理用語に合致するようにしてください。\n- 品目、翻訳、価格のみをリストアップし、追加の説明は不要です。\n- 画像の内容がメニューに見えない場合は、「これはメニューではないようです。メニュー翻訳は実行できません。」と直接返信してください。\n\n回答テンプレート（Markdownリスト使用）：\n- 原文: [原文1], 翻訳: [翻訳1], 価格: [価格1]\n- 原文: [原文2], 翻訳: [翻訳2], 価格: [価格2]\n...`,
                apiPromptMenuMoreInfo: `前回のメニュー翻訳に続いて、このメニュー画像の各項目について、可能であれば簡単な「項目解説」を提供してください。\n- 解説には、主な材料、風味の特徴、量の推測、その他注文に役立つと思われる補足情報を含めることができます。\n- ターゲット言語（${() => AppState.currentTargetLanguage}）の自然な言葉遣いを使用してください。\n- 形式としては、「原文」、「翻訳」、「価格」をリストアップし、その下に「解説」を追加してください。\n\n回答テンプレート（Markdown使用）：\n- 原文: [原文1], 翻訳: [翻訳1], 価格: [価格1]\n  解説: [項目1の解説...]\n- 原文: [原文2], 翻訳: [翻訳2], 価格: [価格2]\n  解説: [項目2の解説...]\n...\n\n画像の内容がメニューに見えない場合、または前回の翻訳でメニューではないと示された場合は、「メニュー以外の内容に関する詳細は提供できません。」と直接返信してください。`,
                moreInfoPlaceholder: 'さらに詳しい情報はこちらに表示されます！', moreInfoPrefix: 'AIの補足説明：\n',
                copyButtonText: 'コピー', copiedButtonText: 'コピー完了!', copyFailedAlert: 'コピー失敗!', noContentCopyAlert: 'コピーする内容がありません。',
                cancelRequestButton: 'リクエストをキャンセル', requestCancelledMessage: 'リクエストはキャンセルされました。', genericError: '不明なエラーが発生しました。後でもう一度お試しください。'
            },
            'ko': {
                apiKeyLabel: 'API 키:', languageLabel: '대상 언어:', saveSettingsButton: '설정 저장 및 시작',
                appTitle: '이게 뭐지? AI 이미지 분석', cameraLoadingText: '카메라 시작 중...', captureButton: '촬영', uploadButtonLabel: '이미지 업로드', zoomLabel: '줌:',
                describeButton: '이게 뭐예요?', menuModeButton: '메뉴 번역', recaptureButton: '다시 촬영', downloadImageButtonLabel: '이미지 다운로드',
                resultPlaceholder: 'AI 분석 결과가 여기에 표시됩니다!', backToSettingsButton: '설정으로 돌아가기',
                alert_apiKeyRequired: 'API 키를 입력해주세요.', alert_cameraError: '카메라를 시작할 수 없습니다: ', alert_apiError: 'API 요청에 실패했습니다. 다시 시도하시겠습니까? ',
                alert_noImage: '먼저 이미지를 촬영하거나 업로드해주세요!', promptHelperText: '이미지 준비 완료! AI 분석을 위해 아래 버튼을 클릭하세요.',
                apiPrompt: `이 사진에 무엇이 있습니까? 아래 "응답 템플릿" 형식을 엄격히 따르고 간단하고 명확한 한국어(${() => AppState.currentTargetLanguage})로 답변하십시오. 이미지 내용을 기반으로 [대괄호] 안의 정보를 입력하십시오. 이미지에서 일부 정보를 식별할 수 없는 경우 해당 [대괄호]에 "명확하지 않음" 또는 "이미지에 표시되지 않음"이라고 작성하십시오. 특정 브랜드나 모델 정보가 없는 경우에도 "명확하지 않음"이라고 작성하십시오.\n\n**이미지의 주요 내용이 메뉴 또는 가격표인 경우:**\n"품명"을 "메뉴" 또는 "가격표"로, "용도"를 "식사 정보 및 가격 제공"으로, "가격"을 "여러 항목의 가격 포함"으로 설정하십시오. 또한, "기타 관찰된 정보"에 "이것은 메뉴인 것 같습니다! 자세한 번역 및 가격은 '메뉴 번역' 버튼을, 항목 설명은 '자세히 알려줘'를 클릭하십시오."라고 사용자에게 명확하게 안내하십시오.\n\n응답 템플릿:\n이것은 "[일반적인 이름 또는 제품 이름]"이라고 합니다.\n용도(또는 주요 성분, 이미지로 판단)는 "[용도/주요 성분/특징 설명]"입니다.\n가격은 "[이미지에 가격이 표시된 경우 제공, 그렇지 않은 경우 위 힌트 사용, 예: 약 XXX원 또는 가격이 표시되지 않음]"입니다.\n\n이미지에 명확한 브랜드 이름, 모델 번호 또는 기타 중요한 텍스트가 있는 경우 마지막에 한 줄을 추가하십시오: "기타 관찰된 정보: [브랜드, 모델 등, 없는 경우 명확하지 않음]".\n답변이 자연스럽고 유창하도록 해주십시오. 감사합니다!`,
                apiResponsePrefix: 'AI 설명：\n', tellMeMoreButtonLabel: '자세히 알려줘',
                apiPromptMoreInfo: `사진 속 주요 품목에 대해 이전의 초기 설명보다 더 자세한 보충 정보를 제공하십시오. 내용은 다음을 포함할 수 있지만 이에 국한되지는 않습니다: 사용 지침, 요리 제안 (해당하는 경우), 유지 관리/보관 (해당하는 경우), 구입처/입수처, 관련 주의사항. 내용을 더 풍부하고 실용적으로 만들기 위해 간결하고 체계적인 한국어(${() => AppState.currentTargetLanguage})로 소개하십시오. 내용을 더 쉽게 읽을 수 있도록 Markdown 형식(예: 제목, 목록, 굵은 텍스트)을 사용하십시오. 그러나 너무 복잡한 Markdown 기호는 피하십시오.`,
                apiPromptMenuInitial: `이것은 메뉴 또는 가격표 이미지입니다. 전문 메뉴 번역가 역할을 해주십시오. 아래 "응답 템플릿" 형식을 엄격히 따르십시오. 이미지에서 명확하게 보이는 모든 항목의 "원문", "대상 언어(${() => AppState.currentTargetLanguage})로의 자연스러운 번역", 그리고 이미지에 표시된 "가격"을 나열하십시오.\n- 항목의 원문, 번역 또는 가격이 이미지에서 불분명한 경우, 해당 필드에 "원문 불분명", "번역 어려움" 또는 "가격 표시 없음"으로 기재하십시오.\n- 번역이 대상 언어의 요리 용어와 일치하도록 하십시오.\n- 항목, 번역, 가격만 나열하고 추가 설명은 하지 마십시오.\n- 이미지 내용이 메뉴로 보이지 않으면 "이것은 메뉴가 아닌 것 같습니다. 메뉴 번역을 수행할 수 없습니다."라고 직접 응답하십시오.\n\n응답 템플릿 (Markdown 목록 사용):\n- 원문: [원문 항목 1], 번역: [번역된 항목 1], 가격: [가격 1]\n- 원문: [원문 항목 2], 번역: [번역된 항목 2], 가격: [가격 2]\n...`,
                apiPromptMenuMoreInfo: `이전 메뉴 번역에 이어, 이 메뉴 이미지의 각 항목에 대해 가능하다면 간단한 "항목 설명"을 제공하십시오.\n- 설명에는 주요 재료, 풍미 특징, 양 추측 또는 주문에 도움이 될 만한 보충 정보가 포함될 수 있습니다.\n- 대상 언어(${() => AppState.currentTargetLanguage})의 자연스러운 표현을 사용하십시오.\n- 형식은 "원문", "번역", "가격"을 나열한 다음 그 아래에 "설명"을 추가하십시오.\n\n응답 템플릿 (Markdown 사용):\n- 원문: [원문 항목 1], 번역: [번역된 항목 1], 가격: [가격 1]\n  설명: [항목 1에 대한 설명...]\n- 원문: [원문 항목 2], 번역: [번역된 항목 2], 가격: [가격 2]\n  설명: [항목 2에 대한 설명...]\n...\n\n이미지 내용이 메뉴로 보이지 않거나 이전 번역에서 메뉴가 아니라고 표시된 경우, "메뉴가 아닌 내용에 대한 자세한 정보를 제공할 수 없습니다."라고 직접 응답하십시오.`,
                moreInfoPlaceholder: '더 자세한 정보가 여기에 표시됩니다!', moreInfoPrefix: 'AI 추가 설명：\n',
                copyButtonText: '복사', copiedButtonText: '복사됨!', copyFailedAlert: '복사 실패!', noContentCopyAlert: '복사할 내용이 없습니다.',
                cancelRequestButton: '요청 취소', requestCancelledMessage: '요청이 취소되었습니다.', genericError: '알 수 없는 오류가 발생했습니다. 나중에 다시 시도하십시오.'
            }
        };

        function debugLog(...args) {
            if (DEBUG_MODE) {
                console.log('[DEBUG]', ...args);
            }
        }

        function performanceLog(label, startTime) {
            if (DEBUG_MODE) {
                const duration = performance.now() - startTime;
                console.log(`[PERF] ${label}: ${duration.toFixed(2)}ms`);
            }
        }

        function getI18nString(key, lang = AppState.currentTargetLanguage) {
            return (i18nData[lang] && i18nData[lang][key]) ? i18nData[lang][key] : key;
        }

        function getProcessedPrompt(promptKey) {
            let promptTemplate = getI18nString(promptKey);
            if (typeof promptTemplate === 'string') {
                 promptTemplate = promptTemplate.replace(/\$\{\(\) => AppState\.currentTargetLanguage\}/g, AppState.currentTargetLanguage);
            } else if (typeof promptTemplate === 'function') {
                 promptTemplate = promptTemplate();
            }
            return promptTemplate;
        }

        function updateCopyButtonVisibility(textAreaElement, placeholderTextKey) {
            const copyButton = textAreaElement.querySelector('.copy-button');
            if (!copyButton) return;

            copyButton.textContent = getI18nString('copyButtonText');
            copyButton.title = getI18nString('copyButtonText');


            const placeholder = getI18nString(placeholderTextKey);
            const currentPrefixKey = textAreaElement.id === 'resultArea' ? 'apiResponsePrefix' : (textAreaElement.id === 'moreInfoArea' ? 'moreInfoPrefix' : null);
            const currentPrefix = currentPrefixKey ? getI18nString(currentPrefixKey) : "";
            
            const clone = textAreaElement.cloneNode(true);
            const buttonInClone = clone.querySelector('.copy-button');
            if (buttonInClone) buttonInClone.remove();

            const htmlContent = clone.innerHTML.trim();
            const textContent = clone.innerText.trim();
            
            const justPrefix = currentPrefix && htmlContent === currentPrefix.trim().replace(/\n/g, '<br>').replace(/\n/g, ''); 
            const isPlaceholder = htmlContent === placeholder.trim();
            
            if (textContent && !isPlaceholder && !justPrefix && textContent !== currentPrefix.trim()) {
                copyButton.style.display = 'inline-block';
            } else {
                copyButton.style.display = 'none';
            }
        }

        function updateUIStrings(lang) {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const translation = getI18nString(key, lang);
                if (el.tagName === 'BUTTON' && el.getAttribute('aria-label')) {
                     el.setAttribute('aria-label', translation); // Assume button text is suitable for aria-label here
                }
                el.textContent = translation;
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                const translation = getI18nString(key, lang);
                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    el.placeholder = translation;
                } else {
                    const currentContentClone = el.cloneNode(true);
                    const copyBtnInClone = currentContentClone.querySelector('.copy-button');
                    if (copyBtnInClone) copyBtnInClone.remove();
                    const currentActualContent = currentContentClone.innerHTML.trim();

                    const placeholderValues = Object.values(i18nData).map(translations => translations[key]).filter(Boolean);
                    let isCurrentlyPlaceholder = false;
                    for(const pVal of placeholderValues) {
                        if (currentActualContent === pVal || currentActualContent === "") {
                            isCurrentlyPlaceholder = true;
                            break;
                        }
                    }
                    const currentPrefixKey = el.id === 'resultArea' ? 'apiResponsePrefix' : (el.id === 'moreInfoArea' ? 'moreInfoPrefix' : null);
                    const currentPrefix = currentPrefixKey ? getI18nString(currentPrefixKey, lang) : "";
                    if (currentActualContent === currentPrefix.trim().replace(/\n/g, '<br>').replace(/\n/g, '')) {
                        isCurrentlyPlaceholder = true; 
                    }

                    if (isCurrentlyPlaceholder) {
                       el.innerHTML = translation; 
                       if (!el.querySelector('.copy-button') && (el.id === 'resultArea' || el.id === 'moreInfoArea')) {
                           const newCopyButton = document.createElement('button');
                           newCopyButton.className = 'copy-button';
                           newCopyButton.setAttribute('data-clipboard-target-id', el.id);
                           newCopyButton.title = getI18nString('copyButtonText', lang);
                           newCopyButton.style.display = 'none';
                           newCopyButton.textContent = getI18nString('copyButtonText', lang);
                           el.appendChild(newCopyButton);
                       }
                    }
                }
            });
            AppState.currentTargetLanguage = lang;
            localStorage.setItem('targetLanguage', lang);
            if (!DOM.controlsAfterCapture.classList.contains('hidden')) {
                DOM.promptHelper.textContent = getI18nString('promptHelperText');
            }
             if (document.getElementById('resultArea')) {
                updateCopyButtonVisibility(document.getElementById('resultArea'), 'resultPlaceholder');
            }
            if (document.getElementById('moreInfoArea')) {
                updateCopyButtonVisibility(document.getElementById('moreInfoArea'), 'moreInfoPlaceholder');
            }
        }
        
        function loadSettings() {
            const savedApiKey = localStorage.getItem('apiKey');
            const savedLanguage = localStorage.getItem('targetLanguage');

            if (savedApiKey) {
                DOM.apiKeyInput.value = savedApiKey;
                AppState.currentApiKey = savedApiKey;
            }
            if (savedLanguage) {
                DOM.targetLanguageSelect.value = savedLanguage;
            } else {
                DOM.targetLanguageSelect.value = 'zh-TW'; 
            }
            updateUIStrings(DOM.targetLanguageSelect.value);
        }

        function stopCameraStream() {
            if (AppState.stream) {
                AppState.stream.getTracks().forEach(track => track.stop());
                AppState.stream = null;
                AppState.videoTrack = null;
                debugLog("Camera stream stopped.");
            }
            DOM.zoomControls.classList.add('hidden');
        }

        async function startCamera() {
            const perfStart = performance.now();
            stopCameraStream(); 
            DOM.cameraLoadingIndicator.classList.remove('hidden');
            DOM.cameraViewDiv.classList.add('hidden');
            clearErrorDisplay();
            try {
                AppState.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                DOM.videoPreview.srcObject = AppState.stream;
                DOM.videoPreview.classList.remove('hidden');
                DOM.cameraViewDiv.classList.remove('hidden'); 
                
                DOM.captureButton.classList.remove('hidden');
                DOM.uploadButton.classList.remove('hidden');

                DOM.capturedImage.style.display = 'none'; 
                DOM.controlsAfterCapture.classList.add('hidden');
                
                resetResultArea();
                DOM.tellMeMoreButton.classList.add('hidden');
                resetMoreInfoArea();

                AppState.videoTrack = AppState.stream.getVideoTracks()[0];
                const capabilities = AppState.videoTrack.getCapabilities();

                if (capabilities.zoom) {
                    DOM.zoomSlider.min = capabilities.zoom.min;
                    DOM.zoomSlider.max = capabilities.zoom.max;
                    DOM.zoomSlider.step = capabilities.zoom.step;
                    let currentZoom = AppState.videoTrack.getSettings().zoom || parseFloat(DOM.zoomSlider.value);
                    if (currentZoom < capabilities.zoom.min) currentZoom = capabilities.zoom.min;
                    if (currentZoom > capabilities.zoom.max) currentZoom = capabilities.zoom.max;
                    DOM.zoomSlider.value = currentZoom;
                    DOM.zoomControls.classList.remove('hidden');
                } else {
                    DOM.zoomControls.classList.add('hidden');
                }

                if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
                    AppState.videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] })
                        .then(() => debugLog("Continuous focus enabled."))
                        .catch(e => console.warn("Could not enable continuous focus:", e));
                }
                debugLog("Camera started successfully.");
                DOM.captureButton.focus();

            } catch (err) {
                console.error("Error accessing camera: ", err);
                displayError(getI18nString('alert_cameraError') + err.message);
                DOM.cameraViewDiv.classList.add('hidden'); 
                DOM.zoomControls.classList.add('hidden');
            } finally {
                DOM.cameraLoadingIndicator.classList.add('hidden');
                performanceLog('Camera Start', perfStart);
            }
        }
        
        function displayError(message) {
            DOM.errorDisplay.textContent = message;
            DOM.errorDisplay.classList.remove('hidden');
        }

        function clearErrorDisplay() {
            DOM.errorDisplay.classList.add('hidden');
            DOM.errorDisplay.textContent = '';
        }

        function resetResultArea(lang = AppState.currentTargetLanguage) {
            const placeholder = getI18nString('resultPlaceholder', lang);
            DOM.resultArea.innerHTML = placeholder + `<button class="copy-button" data-clipboard-target-id="resultArea" title="${getI18nString('copyButtonText', lang)}" style="display:none;">${getI18nString('copyButtonText', lang)}</button>`;
            updateCopyButtonVisibility(DOM.resultArea, 'resultPlaceholder');
        }
        
        function resetMoreInfoArea(lang = AppState.currentTargetLanguage) {
            const placeholder = getI18nString('moreInfoPlaceholder', lang);
            DOM.moreInfoArea.innerHTML = placeholder + `<button class="copy-button" data-clipboard-target-id="moreInfoArea" title="${getI18nString('copyButtonText', lang)}" style="display:none;">${getI18nString('copyButtonText', lang)}</button>`;
            DOM.moreInfoArea.classList.add('hidden');
            updateCopyButtonVisibility(DOM.moreInfoArea, 'moreInfoPlaceholder');
        }

        function setAppButtonsDisabled(disabled) {
            AppState.isApiRequestInProgress = disabled;
            [
                DOM.captureButton, DOM.uploadButton, DOM.describeButton, DOM.menuModeButton,
                DOM.recaptureButton, DOM.downloadImageButton, DOM.tellMeMoreButton,
                DOM.backToSettingsButton, DOM.saveSettingsButton
            ].forEach(button => {
                if (button) button.disabled = disabled;
            });

            if (disabled) {
                DOM.apiInteractionControls.classList.remove('hidden');
                DOM.cancelApiRequestButton.focus();
            } else {
                DOM.apiInteractionControls.classList.add('hidden');
            }
        }


        DOM.saveSettingsButton.addEventListener('click', () => {
            const apiKey = DOM.apiKeyInput.value.trim();
            if (!apiKey) {
                alert(getI18nString('alert_apiKeyRequired'));
                DOM.apiKeyInput.focus();
                return;
            }
            AppState.currentApiKey = apiKey;
            localStorage.setItem('apiKey', apiKey);
            localStorage.setItem('targetLanguage', DOM.targetLanguageSelect.value);

            DOM.settingsView.classList.add('hidden');
            DOM.appView.classList.remove('hidden');
            startCamera();
            DOM.captureButton.focus();
        });

        DOM.targetLanguageSelect.addEventListener('change', (event) => {
            updateUIStrings(event.target.value);
        });

        DOM.zoomSlider.addEventListener('input', () => {
            if (AppState.videoTrack && AppState.videoTrack.applyConstraints) {
                AppState.videoTrack.applyConstraints({ advanced: [{ zoom: parseFloat(DOM.zoomSlider.value) }] })
                    .catch(e => console.error("Zoom error:", e));
            }
        });

        DOM.videoPreview.addEventListener('click', () => {
            if (AppState.videoTrack && AppState.videoTrack.applyConstraints && AppState.videoTrack.getCapabilities().focusMode) {
                const focusModes = AppState.videoTrack.getCapabilities().focusMode;
                if (focusModes.includes('single-shot')) {
                    AppState.videoTrack.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] })
                        .then(() => debugLog("Single-shot focus triggered."))
                        .catch(e => console.warn("Single-shot focus error:", e));
                } else if (focusModes.includes('continuous')) { 
                     AppState.videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] })
                        .catch(e => console.warn("Re-applying continuous focus error:", e));
                }
            }
        });
        
        function showImageAndControls(imageDataUrl) {
            DOM.capturedImage.src = imageDataUrl;
            DOM.capturedImage.style.display = 'block'; 
            
            DOM.videoPreview.classList.add('hidden');
            DOM.zoomControls.classList.add('hidden');
            DOM.cameraViewDiv.classList.add('hidden'); 
            DOM.cameraLoadingIndicator.classList.add('hidden');


            DOM.controlsAfterCapture.classList.remove('hidden'); 
            DOM.promptHelper.textContent = getI18nString('promptHelperText');
            
            resetResultArea();
            DOM.tellMeMoreButton.classList.add('hidden');
            resetMoreInfoArea();
            clearErrorDisplay();

            stopCameraStream();
            DOM.describeButton.focus();
        }

        DOM.captureButton.addEventListener('click', () => {
            const perfStart = performance.now();
            if (!AppState.stream || !DOM.videoPreview.videoWidth) {
                displayError(getI18nString('alert_cameraError') + "Camera not ready.");
                return;
            }
            DOM.canvas.width = DOM.videoPreview.videoWidth;
            DOM.canvas.height = DOM.videoPreview.videoHeight;
            const context = DOM.canvas.getContext('2d');
            context.drawImage(DOM.videoPreview, 0, 0, DOM.canvas.width, DOM.canvas.height);
            
            const imageDataUrl = DOM.canvas.toDataURL('image/jpeg', 0.9);
            showImageAndControls(imageDataUrl);
            performanceLog('Image Capture', perfStart);
        });

        DOM.uploadButton.addEventListener('click', () => {
            DOM.imageUploadInput.click();
        });

        DOM.imageUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    showImageAndControls(e.target.result);
                }
                reader.readAsDataURL(file);
            }
            DOM.imageUploadInput.value = null; 
        });

        DOM.recaptureButton.addEventListener('click', () => {
            startCamera(); 
            DOM.capturedImage.style.display = 'none'; 
            DOM.capturedImage.src = GlobalConstants.DEFAULT_BLANK_IMAGE;
            DOM.controlsAfterCapture.classList.add('hidden');
            
            resetResultArea();
            DOM.tellMeMoreButton.classList.add('hidden');
            resetMoreInfoArea();
            clearErrorDisplay();
        });

        DOM.downloadImageButton.addEventListener('click', () => {
            if (DOM.capturedImage.src && DOM.capturedImage.style.display !== 'none' && DOM.capturedImage.src !== GlobalConstants.DEFAULT_BLANK_IMAGE) {
                const link = document.createElement('a');
                link.href = DOM.capturedImage.src;
                const timestamp = new Date().toISOString().replace(/[:.-]/g, '');
                link.download = `ai_image_${timestamp}.jpeg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert(getI18nString('alert_noImage'));
            }
        });
        
        DOM.cancelApiRequestButton.addEventListener('click', () => {
            if (AppState.currentAbortController) {
                AppState.currentAbortController.abort();
                debugLog("API request cancellation initiated by user.");
            }
        });


        async function callGeminiAPI(promptText, base64ImageData, resultDisplayElement, loadingElement, responsePrefixKey, placeholderTextKey) {
            if (AppState.isApiRequestInProgress) return;

            const perfStart = performance.now();
            if (!base64ImageData) {
                displayError(getI18nString('alert_noImage'));
                return; 
            }
            if (!AppState.currentApiKey) {
                displayError(getI18nString('alert_apiKeyRequired'));
                DOM.settingsView.classList.remove('hidden');
                DOM.appView.classList.add('hidden');
                DOM.apiKeyInput.focus();
                return; 
            }

            AppState.currentAbortController = new AbortController();
            const signal = AppState.currentAbortController.signal;

            setAppButtonsDisabled(true);
            clearErrorDisplay();
            loadingElement.classList.remove('hidden');
            
            const responsePrefix = getI18nString(responsePrefixKey);
            resultDisplayElement.innerHTML = responsePrefix + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
            updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
            resultDisplayElement.classList.remove('hidden');
            
            if (resultDisplayElement === DOM.resultArea) { 
                 DOM.tellMeMoreButton.classList.add('hidden');
                 resetMoreInfoArea();
            }

            const STREAM_API_URL = `${GlobalConstants.GEMINI_API_BASE_URL}${GlobalConstants.GEMINI_MODEL_STREAM}?key=${AppState.currentApiKey}&alt=sse`;
            
            const requestBody = {
                contents: [{
                    parts: [
                        { text: promptText },
                        { inline_data: { mime_type: "image/jpeg", data: base64ImageData } }
                    ]
                }],
                 generationConfig: { temperature: 0.3, maxOutputTokens: 4096 }
            };

            let accumulatedText = "";
            let successStreaming = false; 

            try {
                const response = await fetch(STREAM_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: signal
                });

                if (!response.ok) {
                    let errorJsonMessage = "";
                    try {
                        const errorData = await response.json();
                        errorJsonMessage = errorData.error?.message || 'Unknown API error after non-ok response';
                    } catch (e) {
                        errorJsonMessage = response.statusText || 'Failed to get error details';
                    }
                    throw new Error(`HTTP error! status: ${response.status} - ${errorJsonMessage}`);
                }
                
                if (!response.body) {
                    throw new Error("Response body is null, streaming not possible.");
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let lineBuffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        if (lineBuffer.trim().startsWith('data:')) {
                             try {
                                const jsonString = lineBuffer.substring(lineBuffer.indexOf('{'));
                                const jsonData = JSON.parse(jsonString);
                                if (jsonData.candidates && jsonData.candidates[0].content && jsonData.candidates[0].content.parts && jsonData.candidates[0].content.parts[0].text) {
                                    const textChunk = jsonData.candidates[0].content.parts[0].text;
                                    accumulatedText += textChunk;
                                    resultDisplayElement.innerHTML = responsePrefix + marked.parse(accumulatedText) + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                                    updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
                                    successStreaming = true;
                                }
                            } catch (e) {
                                console.warn("Error parsing final buffered JSON chunk:", e, lineBuffer);
                            }
                        }
                        break;
                    }

                    lineBuffer += decoder.decode(value, { stream: true });
                    let eolIndex;
                    while ((eolIndex = lineBuffer.indexOf('\n')) >= 0) {
                        const line = lineBuffer.substring(0, eolIndex).trim();
                        lineBuffer = lineBuffer.substring(eolIndex + 1);

                        if (line.startsWith('data:')) {
                            try {
                                const jsonString = line.substring(line.indexOf('{')); 
                                const jsonData = JSON.parse(jsonString);
                                
                                if (jsonData.candidates && jsonData.candidates[0].content && jsonData.candidates[0].content.parts && jsonData.candidates[0].content.parts[0].text) {
                                    const textChunk = jsonData.candidates[0].content.parts[0].text;
                                    accumulatedText += textChunk;
                                    resultDisplayElement.innerHTML = responsePrefix + marked.parse(accumulatedText) + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                                    updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
                                    resultDisplayElement.scrollTop = resultDisplayElement.scrollHeight; 
                                    successStreaming = true;
                                } else if (jsonData.promptFeedback && jsonData.promptFeedback.blockReason) {
                                    let blockMessage = `${getI18nString('alert_apiError')} Blocked by API. Reason: ${jsonData.promptFeedback.blockReason}`;
                                    if (jsonData.promptFeedback.safetyRatings) {
                                        blockMessage += `\nDetails: ${jsonData.promptFeedback.safetyRatings.map(r => `${r.category} was ${r.probability}`).join(', ')}`;
                                    }
                                    accumulatedText += `\n\n**API Error:**\n${blockMessage}\n\n`;
                                    resultDisplayElement.innerHTML = responsePrefix + marked.parse(accumulatedText) + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                                    updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
                                    if (resultDisplayElement === DOM.resultArea) DOM.tellMeMoreButton.classList.add('hidden');
                                    successStreaming = true; // Still considered a "successful" stream of error info from API
                                }
                            } catch (e) {
                                console.warn('Error parsing JSON chunk from stream:', e, "Line was: ", line);
                            }
                        }
                    }
                }
                
                if (resultDisplayElement === DOM.resultArea && successStreaming) {
                    const isNotMenuResponse = accumulatedText.includes("不是一份菜單") || accumulatedText.includes("not a menu");
                    const isBlockedResponse = accumulatedText.includes("Blocked by API"); 
                    
                    if (!isNotMenuResponse && !isBlockedResponse && accumulatedText.trim() !== "") {
                         DOM.tellMeMoreButton.classList.remove('hidden');
                         DOM.tellMeMoreButton.focus();
                    } else {
                         DOM.tellMeMoreButton.classList.add('hidden');
                    }
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    debugLog("API request aborted by user or timeout.");
                    displayError(getI18nString('requestCancelledMessage'));
                     if (resultDisplayElement.innerText.trim() === responsePrefix.trim() || resultDisplayElement.innerText.trim() === ''){
                        resultDisplayElement.innerHTML = getI18nString(placeholderTextKey) + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                        updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
                    }
                } else {
                    console.error("Error calling Gemini API (streaming):", error);
                    const errorText = getI18nString('alert_apiError') + error.message;
                    displayError(errorText); // Display error in dedicated area
                    // Optionally, still show something in result area if needed, or clear it
                    if (accumulatedText.trim() === "") {
                         resultDisplayElement.innerHTML = responsePrefix + marked.parse(errorText) + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                    } else {
                         resultDisplayElement.innerHTML += `<hr>${marked.parse(errorText)}`;
                    }
                    updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
                }
                if (resultDisplayElement === DOM.resultArea) DOM.tellMeMoreButton.classList.add('hidden');
                successStreaming = false; 
            } finally {
                loadingElement.classList.add('hidden');
                setAppButtonsDisabled(false);
                AppState.currentAbortController = null; 

                if (!successStreaming && (resultDisplayElement.innerText.trim() === responsePrefix.trim() || resultDisplayElement.innerText.trim() === '')) {
                     resultDisplayElement.innerHTML = getI18nString(placeholderTextKey) + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                } else if (successStreaming && accumulatedText.trim() === '') {
                     displayError(getI18nString('alert_apiError') + "AI did not provide any text output.");
                     resultDisplayElement.innerHTML = responsePrefix + getI18nString('alert_apiError') + "AI did not provide any text output." + `<button class="copy-button" data-clipboard-target-id="${resultDisplayElement.id}" title="${getI18nString('copyButtonText')}" style="display:none;">${getI18nString('copyButtonText')}</button>`;
                }
                updateCopyButtonVisibility(resultDisplayElement, placeholderTextKey);
                performanceLog(`API Call (${promptText.substring(0,20)}...)`, perfStart);
            }
        }


        DOM.describeButton.addEventListener('click', async () => {
            AppState.currentRequestMode = 'describe';
            const base64ImageData = DOM.capturedImage.src.split(',')[1];
            DOM.tellMeMoreButton.classList.add('hidden'); 
            resetMoreInfoArea();
            
            await callGeminiAPI(
                getProcessedPrompt('apiPrompt'),
                base64ImageData,
                DOM.resultArea,
                DOM.loadingIndicator,
                'apiResponsePrefix',
                'resultPlaceholder'
            );
        });

        DOM.menuModeButton.addEventListener('click', async () => {
            AppState.currentRequestMode = 'menu';
            const base64ImageData = DOM.capturedImage.src.split(',')[1];
            DOM.tellMeMoreButton.classList.add('hidden');
            resetMoreInfoArea();

            await callGeminiAPI(
                getProcessedPrompt('apiPromptMenuInitial'),
                base64ImageData,
                DOM.resultArea,
                DOM.loadingIndicator,
                'apiResponsePrefix',
                'resultPlaceholder'
            );
        });

        DOM.tellMeMoreButton.addEventListener('click', async () => {
            const base64ImageData = DOM.capturedImage.src.split(',')[1];
            DOM.moreInfoArea.classList.remove('hidden'); 
            resetMoreInfoArea();

            let moreInfoPromptKey = AppState.currentRequestMode === 'menu' ? 'apiPromptMenuMoreInfo' : 'apiPromptMoreInfo';
            
            await callGeminiAPI(
                getProcessedPrompt(moreInfoPromptKey),
                base64ImageData,
                DOM.moreInfoArea,
                DOM.moreInfoLoadingIndicator, 
                'moreInfoPrefix',
                'moreInfoPlaceholder'
            );
        });

        DOM.backToSettingsButton.addEventListener('click', () => {
            stopCameraStream();
            DOM.appView.classList.add('hidden');
            DOM.settingsView.classList.remove('hidden');
            
            DOM.capturedImage.src = GlobalConstants.DEFAULT_BLANK_IMAGE; 
            DOM.capturedImage.style.display = 'none'; 
            DOM.controlsAfterCapture.classList.add('hidden');
            
            resetResultArea();
            DOM.tellMeMoreButton.classList.add('hidden');
            resetMoreInfoArea();
            clearErrorDisplay();
            
            DOM.cameraViewDiv.classList.remove('hidden'); 
            DOM.videoPreview.classList.remove('hidden'); 
            DOM.captureButton.classList.remove('hidden'); 
            DOM.uploadButton.classList.remove('hidden');
            DOM.zoomControls.classList.add('hidden'); 
            DOM.apiKeyInput.focus();
        });

        DOM.appView.addEventListener('click', async (event) => {
            const button = event.target.closest('.copy-button');
            if (button) {
                const targetId = button.getAttribute('data-clipboard-target-id');
                const targetElement = document.getElementById(targetId);

                if (targetElement) {
                    const clone = targetElement.cloneNode(true);
                    const buttonInClone = clone.querySelector('.copy-button');
                    if (buttonInClone) buttonInClone.remove();
                    let textToCopy = clone.innerText || clone.textContent || ""; 
                    const lang = AppState.currentTargetLanguage; 
                    const prefixes = [
                        getI18nString('apiResponsePrefix', lang),
                        getI18nString('moreInfoPrefix', lang)
                    ].filter(Boolean); 

                    for (const prefix of prefixes) {
                        if (textToCopy.startsWith(prefix)) {
                            textToCopy = textToCopy.substring(prefix.length).trim();
                            break; 
                        }
                    }

                    if (textToCopy.trim()) {
                        try {
                            await navigator.clipboard.writeText(textToCopy);
                            const originalTextKey = 'copyButtonText';
                            const copiedTextKey = 'copiedButtonText';
                            button.textContent = getI18nString(copiedTextKey, lang);
                            setTimeout(() => {
                                button.textContent = getI18nString(originalTextKey, AppState.currentTargetLanguage);
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy: ', err);
                            alert(getI18nString('copyFailedAlert', lang));
                        }
                    } else {
                        alert(getI18nString('noContentCopyAlert', lang));
                    }
                }
            }
        });
        
        window.addEventListener('beforeunload', () => {
            debugLog("beforeunload event triggered. Stopping camera stream.");
            stopCameraStream();
            if (AppState.currentAbortController) {
                AppState.currentAbortController.abort(); // Cancel any ongoing API request
            }
        });

        function initializeApp() {
            loadSettings();
            if (AppState.currentApiKey) { 
                 DOM.settingsView.classList.add('hidden');
                 DOM.appView.classList.remove('hidden');
                 startCamera();
                 DOM.captureButton.focus();
            } else {
                DOM.settingsView.classList.remove('hidden');
                DOM.appView.classList.add('hidden');
                DOM.apiKeyInput.focus();
            }
        }

        initializeApp();
    </script>
</body>
</html>
